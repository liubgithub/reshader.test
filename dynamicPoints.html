<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>gltf model</title>
<style type="text/css">
    html,
    body {
        margin: 0px;
        height: 100%;
        width: 100%
    }

    .container {
        width: 1000px;
        height: 800px
    }
</style>
<script type="text/javascript" src="./js/maptalks.js"></script>
<script type="text/javascript" src="js/maptalksgl-dev.js" type="text/javascript"></script>
<script type="text/javascript" src="js/gltf-loader-dev.js" type="text/javascript"></script>

<body>
    <canvas id="canvas" width=1000 height=800 class="container" style="border : 1px solid"></canvas>
    <input id="enableAnimation" type="button" value="开启动画"/>
    <input id="actionButton" type="button" value="下落"/>
    <!-- <script src="./common/regl.js" type="text/javascript"></script> -->
    <script type="module">
        import quadVert from './shaders/quadVert.js';
        import pointsVert from './shaders/BloomPoints/PointsVert.js';
        import pointsFrag from './shaders/BloomPoints/PointsFrag.js';
        import bloomPointsFrag from './shaders/BloomPoints/BloomPointsFrag.js';
        import quadSceneFrag from './shaders/QuadSceneFrag.js';
        const { createREGL, mat4, reshader } = maptalksgl;
        const MODES = ['points', 'lines', 'line strip', 'line loop', 'triangles', 'triangle strip', 'triangle fan'];
        let camPos = [0, 0, 6];
        const cameraNearFar = [0.1, 200];
        let mouseDown = false;
        let roll = Math.PI;
        let pitch = 0.0;
        let delta = 0.0;
        let translate = 4.0;
        var wheelSpeed = 1.04;
        let lastMouseX = null;
        let lastMouseY = null;
        let enableAnim = false;
        let action = 0;
        const TEXTURE_SAMPLER = {
            '9728': 'nearest',
            '9729': 'linear',
            '9984': 'nearest mipmap nearest',
            '9985': 'linear mipmap nearest',
            '9986': 'nearest mipmap linear',
            '9987': 'linear mipmap linear',
            '33071': 'clamp ro edge',
            '33684': 'mirrored repeat',
            '10497': 'repeat'
        };
        const regl = createREGL({
            canvas: canvas,
            extensions: [
                'OES_texture_float',
                'OES_element_index_uint',
                'OES_standard_derivatives',
                'EXT_shader_texture_lod'
            ]
        });

        // let iblMaps;
        let scene;
        const quadScene = getQuadScene();
        // const loader = new reshader.ResourceLoader(regl.texture(2));
        const renderer = new reshader.Renderer(regl);

        const viewport = {
            x: 0,
            y: 0,
            width: () => {
                return canvas.width;
            },
            height: () => {
                return canvas.height;
            }
        };

        const SceneShader = new reshader.MeshShader({
            vert: pointsVert,
            frag: pointsFrag,
            uniforms: [
                'projectionMatrix',
                'size',
                'scale',
                'toneMappingExposure',
                'diffuse',
                'opacity',
                'fogColor',
                'fogDensity',
                {
                    name: 'modelViewMatrix',
                    type: 'function',
                    fn: function (context, props) {
                        return mat4.multiply([], props['viewMatrix'], props['modelMatrix']);
                    }
                }
            ],
            positionAttribute: 'POSITION',
            extraCommandProps: {
                viewport
                // viewport : {
                //     x : 0, y : 0,
                //     width : 256, height : 256
                // } 
            },
            defines: {
            }
        });

        const BloomPointsShader = new reshader.MeshShader({
            vert: quadVert,
            frag: bloomPointsFrag,
            uniforms: [
                'uImageIncrement',
                'cKernel[25]',
                'tDiffuse',
            ],
            positionAttribute: 'POSITION',
            extraCommandProps: { viewport,
                blend: {
                    enable: true,
                    func: {
                        srcRGB: 'src alpha',
                        srcAlpha: 'src alpha',
                        dstRGB: 1,
                        dstAlpha: 1
                    },
                    equation: {
                        rgb: 'add',
                        alpha: 'add'
                    },
                    color: [0, 0, 0, 0]
                }
            },
            defines: {
                USE_KERNEL_SIZE : 1
            }
        });

        const QuadSceneShader = new reshader.MeshShader({
            vert : quadVert,
            frag : quadSceneFrag,
            uniforms : [
                'sceneTexture',
            ],
            positionAttribute : 'POSITION',
            extraCommandProps: { viewport }
        });

        const fbo_scene = regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag: 'linear',
                min: 'linear'
            }),
            depth: true
        });
        
        const fbo_bloom_x = regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag: 'linear',
                min: 'linear'
            }),
            depth: true
        });
        const fbo_bloom_y = regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag: 'linear',
                min: 'linear'
            }),
            depth: true
        });
        function drawSceneFBO(matrix) {
            const uniforms = {
                'projectionMatrix': matrix.projMatrix,
                'viewMatrix': matrix.viewMatrix,
                'size': 0.01,
                'scale': 468.5,
                'toneMappingExposure': 1,
                'diffuse': [1, 0.8667, 0.2667],
                'opacity': 1,
                'fogColor': [0, 0.0039, 0.0157],
                'fogDensity': 0.15
            }
            renderer.render(
                SceneShader,
                // 手动填入的uniform 值
                // 有一个uniform会自动设置：model， 值是mesh的localTransform
                uniforms,
                scene,
                fbo_scene,   //最后一个参数是framebuffer，可以指定framebuffer目标
            );
        }
        
        const cKernel = [0.0011, 0.0023, 0.0044, 0.0079, 0.0135, 0.0216, 0.0324, 0.0457, 0.0606, 0.0754, 0.0882, 0.0968, 0.0999, 0.0968, 0.0882, 0.0754, 0.0606, 0.0457, 0.0324, 0.0216, 0.0135, 0.0079, 0.0044, 0.0023, 0.0011];

        function drawBloomPoints() {
            renderer.render(BloomPointsShader, {
                'uImageIncrement' : [0.002, 0],
                'cKernel': cKernel,
                'tDiffuse': fbo_scene,
            }, quadScene, fbo_bloom_x);

            renderer.render(BloomPointsShader, {
                'uImageIncrement' : [0, 0.002],
                'cKernel': cKernel,
                'tDiffuse': fbo_bloom_x,
            }, quadScene, fbo_scene);
        }

        function drawBlendQuad() {
            renderer.render(QuadSceneShader, {
                'sceneTexture': fbo_scene,
            }, quadScene);
        }

        function drawAll() {
            const matrix = getViewProjection(camPos, canvas.width / canvas.height);
            regl.clear({
                color: [0, 0.0039, 0.0157, 1]
            });
            if (enableAnim) {
                updatePaticles();
            }
            clearFBO();
            drawSceneFBO(matrix);
            drawBloomPoints();
            drawBlendQuad();
            requestAnimationFrame(drawAll);
        }

        //主绘制方法
        function render() {
            // camera's position
            const scenePromise = getScene();
            scenePromise.then(result => {
                scene = result;
                drawAll();
            });
        }

        render();
        let current = 0;
        let end = 180;
        function updatePaticles() {
            if (current >= end) {
                current = 0;
                return;
            }
            const meshes = scene.getMeshes();
            for ( var i = 0; i < meshes.length; i ++ ) {
                var mesh = meshes[i];
                const speed = (mesh.maxY - mesh.minY) / 180;
                var positions = mesh.geometry.data['POSITION'];
                var initialPosition = mesh.geometry.data['initialPosition'];
                const maxDistance = mesh.maxY - mesh.minY;
                for (let i = 0; i < positions.length; i+=3) {
                    const px = positions[i];
                    const py = positions[i + 1];
                    const pz = positions[i + 2];
                    if (py > mesh.minY && action == 0) {
                        const dy = py - mesh.minY;
                        positions[i + 1] = initialPosition[i + 1] - speed * current;
                        positions[i] = positions[i] + (Math.random() * 2 - 1) * 0.01;
                        positions[i + 2] += (Math.random() * 2 - 1) * 0.01;
                    } else if(action == 1) {
                        positions[i + 1] = positions[i + 1] < initialPosition[i + 1] ? mesh.minY + speed * current : initialPosition[i + 1];
                        positions[i] = positions[i] + (Math.random() * 2 - 1) * 0.01;
                        positions[i + 2] += (Math.random() * 2 - 1) * 0.01;
                    }
                }
            }
            current++;
        }
        function _updatePaticles() {
            delta = delta < 2 ? delta : 2;
            const meshes = scene.getMeshes();
            for ( var j = 0; j < meshes.length; j ++ ) {
                var mesh = meshes[j];
                var positions = mesh.geometry.data['POSITION'];
                var initialPositions = mesh.geometry.data['initialPosition'];
                var count = positions.length;
                if ( mesh.start > 0 ) {
                    mesh.start -= 1;
                } else {
                    if ( mesh.direction === 0 ) {
                        mesh.direction = - 1;
                    }
                }
                for ( var i = 0; i < count; i += 3 ) {
                    var px = positions[i];
                    var py = positions[i + 1];
                    var pz = positions[i + 2];
                    // falling down
                    if ( mesh.direction < 0 ) {
                        if ( py > mesh.minY ) {
                            // positions.setXYZ(
                            //     i,
                            //     px + 1.5 * ( 0.50 - Math.random() ) * mesh.speed * delta,
                            //     py + 3.0 * ( 0.25 - Math.random() ) * mesh.speed * delta,
                            //     pz + 1.5 * ( 0.50 - Math.random() ) * mesh.speed * delta
                            // );
                            positions[i] = px + 1.5 * ( 0.0050 - Math.random() ) * mesh.speed * delta;
                            positions[i + 1] = py + 3.0 * ( 0.0025 - Math.random() ) * mesh.speed * delta;
                            positions[i + 2] = pz + 1.5 * ( 0.0050 - Math.random() ) * mesh.speed * delta;
                        } else {
                            mesh.verticesDown += 1;
                        }
                    }
                    // rising up
                    if ( mesh.direction > 0 ) {
                        var ix = initialPositions[i];
                        var iy = initialPositions[i + 1];
                        var iz = initialPositions[i + 2];
                        var dx = Math.abs( px - ix );
                        var dy = Math.abs( py - iy );
                        var dz = Math.abs( pz - iz );
                        var d = dx + dy + dx;
                        if ( d > 1 ) {
                            // positions.setXYZ(
                            //     i,
                            //     px - ( px - ix ) / dx * mesh.speed * delta * ( 0.85 - Math.random() ),
                            //     py - ( py - iy ) / dy * mesh.speed * delta * ( 1 + Math.random() ),
                            //     pz - ( pz - iz ) / dz * mesh.speed * delta * ( 0.85 - Math.random() )
                            // );
                            positions[i] = px - (px - ix) / dx * mesh.speed * delta * (0.0085 - Math.random());
                            positions[i + 1] = py - (py - iy) / dy * mesh.speed * delta * (0.01 + Math.random());
                            positions[i + 2] = pz - (pz - iz) / dz * mesh.speed * delta * (0.0085 - Math.random());
                        } else {
                            mesh.verticesUp += 1;
                        }
                    }
                }
                // all vertices down
                if ( mesh.verticesDown >= count ) {
                    if ( mesh.delay <= 0 ) {
                        mesh.direction = 1;
                        mesh.speed = 0.05;
                        mesh.verticesDown = 0;
                        mesh.delay = 3.2;
                    } else {
                        mesh.delay -= 0.01;
                    }
                }
                // all vertices up
                if ( mesh.verticesUp >= count ) {
                    if ( mesh.delay <= 0 ) {
                        mesh.direction = - 1;
                        mesh.speed = 0.15;
                        mesh.verticesUp = 0;
                        mesh.delay = 1.2;
                    } else {
                        mesh.delay -= 0.01;
                    }

                }
            }
            delta += 2 / 125;
        }
        //设置纹理
        //TODO, 实现PBR的纹理
        function setPhongTexture(material, modelMesh) {
            const baseColorTexture = material.pbrMetallicRoughness.baseColorTexture;
            if (baseColorTexture) {
                const texture = setTexture(baseColorTexture.texture);
                modelMesh.setDefines({
                    USE_BASECOLORTEXTURE: 1
                });
                modelMesh.setUniform('sample', texture);
            }
        }

        function setTexture(tex) {
            const data = tex.image.array;
            const sampler = tex.sampler;
            const width = tex.image.width;
            const height = tex.image.height;
            const texture = regl.texture({
                width,
                height,
                data,
                mag: TEXTURE_SAMPLER[sampler.magFilter] || TEXTURE_SAMPLER['9728'],
                min: TEXTURE_SAMPLER[sampler.minFilter] || TEXTURE_SAMPLER['9728'],
                wrapS: TEXTURE_SAMPLER[sampler.wrapS] || TEXTURE_SAMPLER['10497'],
                wrapT: TEXTURE_SAMPLER[sampler.wrapT] || TEXTURE_SAMPLER['10497']
            });
            return texture;
        }

        function getQuadScene() {
            const plane = new reshader.Geometry({
                POSITION: [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]
            }, 6, 0, {
                    primitive: 'triangle',
                    positionAttribute: 'POSITION',
                    positionSize: 2
                });
            const planeMesh = new reshader.Mesh(plane);
            const scene = new reshader.Scene([planeMesh]);
            return scene;
        }

        function getScene() {
            var url = 'gltf/DamagedHelmet/glTF/DamagedHelmet.gltf';
            return gltf.Ajax.getJSON(url, {}).then((json) => {
                const loader = new gltf.GLTFLoader('gltf/DamagedHelmet/glTF', json);
                return loader.load().then(gltfData => {
                    // console.log(gltfData);
                    const transformMat = mat4.identity([]);
                    // mat4.translate(transformMat, transformMat, [0, 1, 0]);
                    mat4.rotate(transformMat, transformMat, 90, [1, 0, 0]);
                    // mat4.scale(transformMat, transformMat, [0.5, 0.5, 0.5]);
                    const modelMeshes = [];
                    const nodes = gltfData.scenes[0].nodes;
                    nodes.forEach((node, i) => {
                        if (!node.meshes && !node.children) {
                            return;
                        }
                        let meshes = null;
                        if (node.children) {
                            meshes = extractMesh(node.children);
                        } else if (node.meshes) {
                            meshes = node.meshes;
                        }
                        meshes.forEach(mesh => {
                            mesh.primitives.forEach(primitive => {
                                const modelGeometry = createGeometry(primitive);
                                //modelGeometry.generateBuffers(this.regl);//会抛elements must be array to build unique vertex.的异常，
                                const modelMesh = new reshader.Mesh(modelGeometry);
                                setYMaxMin(modelMesh);
                                modelMesh.delay = Math.floor(2 + 2 * Math.random());
					            modelMesh.start = Math.floor( 1 + 2 * Math.random());
                                modelMeshes.push(modelMesh);
                                // setPhongTexture(primitive.material, modelMesh);
                                modelMesh.setLocalTransform(transformMat);
                            });
                        });
                    });
                    const scene = new reshader.Scene(modelMeshes);
                    return scene;
                });
            });
        }
        
        function setYMaxMin(mesh) {
            var positions = mesh.geometry.data['POSITION'];
            const yPositions = [];
            for(let i = 1;i < positions.length; i+=3) {
                yPositions.push(positions[i]);
            }
            mesh.maxY = Math.max.apply(null, yPositions);
            mesh.minY = Math.min.apply(null, yPositions);
        }

        function createGeometry(primitive) {
            const attributes = {};
            for (const attr in primitive.attributes) {
                attributes[attr] = primitive.attributes[attr].array;
            }
            attributes['initialPosition'] = JSON.parse(JSON.stringify(attributes['POSITION']));
            const modelGeometry = new reshader.Geometry(
                attributes,
                attributes['POSITION'].length / 3,
                0,
                {
                    //绘制类型，例如 triangle strip, line等，根据gltf中primitive的mode来判断，默认是triangles
                    primitive: MODES[0],
                    positionAttribute: 'POSITION',
                    normalAttribute: 'NORMAL',

                }
            );
            return modelGeometry;
        }

        function getViewProjection(cameraPos) {
            const aspect = canvas.width / canvas.height;
            const projMatrix = mat4.perspective([], 60 * Math.PI / 180, aspect, cameraNearFar[0], cameraNearFar[1]);
            //const viewMatrix = mat4.lookAt([], cameraPos, [0, 0, 0], [0, 1, 0]);
            var xRotation = mat4.create();
            mat4.rotateY(xRotation, xRotation, roll);
            var yRotation = mat4.create();
            mat4.rotateX(yRotation, yRotation, pitch);
            var viewMatrix = mat4.create();
            mat4.multiply(viewMatrix, yRotation, xRotation);
            viewMatrix[14] = -translate;
            const projViewMatrix = mat4.multiply([], projMatrix, viewMatrix);
            return { projViewMatrix, projMatrix, viewMatrix };
        }

        function clearFBO() {
            regl.clear({
                color : [0, 0, 0, 1],
                depth: 1,
                framebuffer : fbo_scene
            });
            regl.clear({
                color : [0, 0, 0, 1],
                depth: 1,
                framebuffer : fbo_bloom_x
            });
        }

        //鼠标事件相关
        canvas.onmousedown = function (ev) { handleMouseDown(ev); };
        canvas.onmouseup = function (ev) { handleMouseUp(ev); };
        canvas.onmousemove = function (ev) { handleMouseMove(ev); };
        canvas.onwheel = function (ev) { handleWheel(ev); };

        function handleMouseDown(ev) {
            mouseDown = true;
            lastMouseX = ev.clientX;
            lastMouseY = ev.clientY;
        }

        function handleMouseUp(ev) {
            mouseDown = false;
        }

        function handleMouseMove(ev) {
            if (!mouseDown) {
                return;
            }
            var newX = ev.clientX;
            var newY = ev.clientY;

            var deltaX = newX - lastMouseX;
            roll += (deltaX / 100.0);

            var deltaY = newY - lastMouseY;
            pitch += (deltaY / 100.0);

            lastMouseX = newX;
            lastMouseY = newY;
            updateCamera();
        }
        function handleWheel(ev, redraw) {
            ev.preventDefault();
            if (ev.deltaY > 0) {
                translate *= wheelSpeed;
            }
            else {
                translate /= wheelSpeed;
            }
            updateCamera();
        }

        function updateCamera() {
            camPos = [-translate * Math.sin(roll) * Math.cos(-pitch),
            -translate * Math.sin(-pitch),
            translate * Math.cos(roll) * Math.cos(-pitch)];
        }

        enableAnimation.onclick = function() {
            enableAnim = !enableAnim;
        }

        actionButton.onclick = function() {
             action = action === 0 ? 1 : 0;
             actionButton.value = action === 0 ? '下落' : '上升';
        }
    </script>
</body>

</html>