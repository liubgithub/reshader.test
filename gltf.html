<!DOCTYPE html>
<html>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gltf model</title>
  <style type="text/css">
    html,body{margin:0px;height:100%;width:100%}
    .container{width:1000px;height:800px}
  </style>
  <script type="text/javascript" src="./js/maptalks.js"></script>
  <script  type="text/javascript" src="js/maptalksgl-dev.js" type="text/javascript"></script>
  <script  type="text/javascript" src="js/gltf-loader-dev.js" type="text/javascript"></script>
  <body>
    <canvas id="canvas" width=1000 height=800 class="container" style="border : 1px solid"></canvas>
    <!-- <script src="./common/regl.js" type="text/javascript"></script> -->
    <script type="module">
        import outlineVert from './shaders/quadVert.js';
        import depth_vert from './shaders/depthVert.js';
        import depth_frag from './shaders/depthFrag.js';
        import A_vert from './shaders/bloom/AVert.js';
        import A_frag from './shaders/bloom/AFrag.js';
        import B_frag from './shaders/bloom/BFrag.js';
        import C_frag from './shaders/bloom/CFrag.js';
        import D_frag from './shaders/bloom/DFrag.js';
        import Edage_frag from './shaders/EdageFrag.js';
        import QuadScene_frag from './shaders/QuadSceneFrag.js';
        const { createREGL, mat4, reshader } = maptalksgl;
        const MODES = ['points', 'lines', 'line strip', 'line loop', 'triangles', 'triangle strip', 'triangle fan'];
        let camPos = [0, 0, 6];
        const cameraNearFar = [0.1, 200];
        let mouseDown = false;
        let roll = Math.PI;
        let pitch = 0.0;
        let translate = 4.0;
        var wheelSpeed = 1.04;
        let lastMouseX = null;
        let lastMouseY = null;
        const TEXTURE_SAMPLER = {
            '9728' : 'nearest',
            '9729' : 'linear',
            '9984' : 'nearest mipmap nearest',
            '9985' : 'linear mipmap nearest',
            '9986' : 'nearest mipmap linear',
            '9987' : 'linear mipmap linear',
            '33071' : 'clamp ro edge',
            '33684' : 'mirrored repeat',
            '10497' : 'repeat'
        };
        const regl = createREGL({
            canvas : canvas,
            extensions : [
                'OES_texture_float',
                'OES_element_index_uint',
                'OES_standard_derivatives',
                'EXT_shader_texture_lod'
            ]
        });

        // let iblMaps;
        let scene;
        const quadScene = getQuadScene();
        // const loader = new reshader.ResourceLoader(regl.texture(2));
        const renderer = new reshader.Renderer(regl);

        const viewport = {
            x: 0,
            y: 0,
            width: () => {
                return canvas.width;
            },
            height: () => {
                return canvas.height;
            }
        };
        const halfViewport = {
            x: 0,
            y: 0,
            width: () => {
                return canvas.width / 2;
            },
            height: () => {
                return canvas.height / 2;
            }
        };

        const fbo_edg =  regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag : 'linear',
                min : 'linear'
            }),
            depth: true
        });
        
        const fbo_depth = regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag : 'linear',
                min : 'linear'
            }),
            depth: true
        });
        const fbo_a =  regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag : 'linear',
                min : 'linear'
            }),
            depth: true
        });
        const fbo_b =  regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag : 'linear',
                min : 'linear'
            }),
            depth: true
        });
        const fbo_c =  regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag : 'linear',
                min : 'linear'
            }),
            depth: true
        });
        const fbo_d =  regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag : 'linear',
                min : 'linear'
            }),
            depth: true
        });
        const fbo_e =  regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag : 'linear',
                min : 'linear'
            }),
            depth: true
        });
        const fbo_f =  regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag : 'linear',
                min : 'linear'
            }),
            depth: true
        });
        const fbo_g =  regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height,
                wrap: 'clamp',
                mag : 'linear',
                min : 'linear'
            }),
            depth: true
        });

        const depth_shader = new reshader.MeshShader({
            vert : depth_vert,
            frag : depth_frag,
            uniforms : [
               {
                    name : 'projViewModelMatrix',
                    type : 'function',
                    fn : function (context, props) {
                        return mat4.multiply([], props['projViewMatrix'], props['modelMatrix']);
                    }
                }
            ],
            positionAttribute : 'POSITION',
            extraCommandProps: { viewport },
            defines : {
            }
        });
        const A_shader = new reshader.MeshShader({
            vert : A_vert,
            frag : A_frag,
            uniforms : [
                'projectionMatrix',
                'viewMatrix',
                'cameraPosition',
                'depthTexture',
                'cameraNearFar',
                {
                    name : 'textureMatrix',
                    type : 'function',
                    fn : function(context, props) {
                        const textureMatrix = mat4.set([], 0.5, 0.0, 0.0, 0.5,
                            0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                        mat4.multiply(textureMatrix, textureMatrix, props['viewMatrix']);
                        const inverseMatrix = mat4.invert([], props['modelMatrix']);
                        mat4.multiply(textureMatrix, textureMatrix, inverseMatrix);
                        return textureMatrix;
                    }
                },
                {
                    name : 'modelViewMatrix',
                    type : 'function',
                    fn : function (context, props) {
                        return mat4.multiply([], props['viewMatrix'], props['modelMatrix']);
                    } 
                }
            ],
            positionAttribute : 'POSITION',
            extraCommandProps: { viewport,
                cull: {
                    enable: false
                }
            },
        });

        const B_shader = new reshader.MeshShader({
            vert : outlineVert,
            frag : B_frag,
            uniforms : [
                'opacity',
                'tDiffuse'
            ],
            positionAttribute : 'POSITION',
            extraCommandProps: { viewport,
                cull: {
                    enable: true
                }
            },
        });

        const C_shader = new reshader.MeshShader({
            vert : outlineVert,
            frag : C_frag,
            uniforms : [
                'texSize',
                'visibleEdgeColor',
                'hiddenEdgeColor',
                'maskTexture'
            ],
            positionAttribute : 'POSITION',
            extraCommandProps: { viewport, depth: {
                    enable: true,
                    mask: true,
                }
            },
        });

        const D_shader = new reshader.MeshShader({
            vert : outlineVert,
            frag : D_frag,
            uniforms : [
                'texSize',
                'direction',
                'kernelRadius',
                'colorTexture'
            ],
            positionAttribute : 'POSITION',
            extraCommandProps: { viewport },
        });

        const Edage_shader = new reshader.MeshShader({
            vert : outlineVert,
            frag : Edage_frag,
            uniforms : [
                'edgeStrength',
                'edgeGlow',
                'maskTexture',
                'edgeTexture1',
                'edgeTexture2'
            ],
            positionAttribute : 'POSITION',
            extraCommandProps: { viewport,
                blend: {
                    enable: true,
                    func: {
                        srcRGB: 'src alpha',
                        srcAlpha: 'src alpha',
                        dstRGB: 1,
                        dstAlpha: 1
                    },
                    equation: {
                        rgb: 'add',
                        alpha: 'add'
                    },
                    color: [0, 0, 0, 0]
                }
            }
        });

        const QuadScene_shader = new reshader.MeshShader({
            vert : outlineVert,
            frag : QuadScene_frag,
            uniforms : [
                'sceneTexture',
            ],
            positionAttribute : 'POSITION',
            extraCommandProps: { viewport
            }
        });

        const SceneShader = new reshader.PhongShader({
            positionAttribute : 'POSITION'
        });
        function drawDepthFBO(marix) {
            renderer.render(depth_shader, {
                'projViewMatrix' : marix.projViewMatrix
            }, scene, fbo_depth);
        }

        function drawAFBO(matrix) {
            renderer.render(A_shader, {
                'projectionMatrix' : matrix.projMatrix,
                'viewMatrix' : matrix.viewMatrix,
                'cameraPosition' : camPos,
                'depthTexture' : fbo_depth,
                'cameraNearFar' : cameraNearFar,
            }, scene, fbo_a);
        }

        function drawBFBO() {
            renderer.render(B_shader, {
                'opacity' : 1,
                'tDiffuse' : fbo_a,
            }, quadScene, fbo_b);
        }

        function drawCFBO() {
            renderer.render(C_shader, {
                'texSize' : [canvas.width / 2, canvas.height / 2],
                'visibleEdgeColor' : [1, 1, 0],
                'hiddenEdgeColor' : [0.1000, 0.0400, 0.0200],
                'maskTexture' : fbo_b
            }, quadScene, fbo_c);
        }

        function drawDFBO() {
            renderer.render(D_shader, {
                'texSize' : [canvas.width / 2, canvas.height / 2],
                'direction' : [1, 0],
                'kernelRadius' : 1,
                'colorTexture' : fbo_c
            }, quadScene, fbo_d);
        }

        function drawEFBO() {
            renderer.render(D_shader, {
                'texSize' : [canvas.width / 2, canvas.height / 2],
                'direction' : [0, 1],
                'kernelRadius' : 1,
                'colorTexture' : fbo_d
            }, quadScene, fbo_e);
        }

        function drawFFBO() {
            renderer.render(D_shader, {
                'texSize' : [canvas.width / 4, canvas.height / 4],
                'direction' : [1, 0],
                'kernelRadius' : 2,
                'colorTexture' : fbo_e
            }, quadScene, fbo_f);
        }

        function drawGFBO() {
            renderer.render(D_shader, {
                'texSize' : [canvas.width / 4, canvas.height / 4],
                'direction' : [0, 1],
                'kernelRadius' : 2,
                'colorTexture' : fbo_f
            }, quadScene, fbo_g);
        }

        function drawEdageFBO() {
            renderer.render(Edage_shader, {
                'edgeStrength' : 3,
                'edgeGlow' : 1,
                'maskTexture' : fbo_b,
                'edgeTexture1' : fbo_d,
                'edgeTexture2' : fbo_g
            }, quadScene, fbo_edg);
        }
       
        function drawSceneFBO(matrix) {      
            const material = new reshader.PhongMaterial({
                viewPos : camPos,
                projViewMatrix : matrix.projViewMatrix
            });
            renderer.render(
                SceneShader,
                // 手动填入的uniform 值
                // 有一个uniform会自动设置：model， 值是mesh的localTransform
                material.getUniforms(),
                scene,
                fbo_edg  //最后一个参数是framebuffer，可以指定framebuffer目标
            );
        }

        function drawQuadScene() {
            renderer.render(QuadScene_shader, {
                'sceneTexture' : fbo_edg,
            }, quadScene);
        }

        function drawAll() {
            const matrix = getViewProjection(camPos, canvas.width / canvas.height);
            clearFBO();
           drawSceneFBO(matrix);
            // drawDepthFBO(matrix);
            drawAFBO(matrix);
            drawBFBO();
            drawCFBO();
            drawDFBO();
            drawEFBO();
            drawFFBO();
            drawGFBO();
            drawEdageFBO();
            drawQuadScene();
            requestAnimationFrame(drawAll);
        }

        //主绘制方法
        function render() {
            // camera's position
            const scenePromise = getScene();
            scenePromise.then(result => {
                scene = result;
                drawAll();
            });
        }

        render();

          //设置纹理
        //TODO, 实现PBR的纹理
        function setPhongTexture(material, modelMesh) {
            const baseColorTexture = material.pbrMetallicRoughness.baseColorTexture;
            if (baseColorTexture) {
                const texture = setTexture(baseColorTexture.texture);
                modelMesh.setDefines({
                    USE_BASECOLORTEXTURE:1
                });
                modelMesh.setUniform('sample', texture);
            }
        }

        function setTexture(tex) {
            const data = tex.image.array;
            const sampler = tex.sampler;
            const  width = tex.image.width;
            const height = tex.image.height;
            const texture = regl.texture({
                width,
                height,
                data,
                mag : TEXTURE_SAMPLER[sampler.magFilter] || TEXTURE_SAMPLER['9728'],
                min : TEXTURE_SAMPLER[sampler.minFilter] || TEXTURE_SAMPLER['9728'],
                wrapS : TEXTURE_SAMPLER[sampler.wrapS] || TEXTURE_SAMPLER['10497'],
                wrapT : TEXTURE_SAMPLER[sampler.wrapT] || TEXTURE_SAMPLER['10497']
            });
            return texture;
        }

        function getQuadScene() {
            const plane = new reshader.Geometry({
                POSITION: [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]
            }, 6, 0, {
                    primitive: 'triangle',
                    positionAttribute : 'POSITION',
                    positionSize: 2
                });
            const planeMesh = new reshader.Mesh(plane);
            const scene = new reshader.Scene([planeMesh]);
            return scene;
        }

        function getScene() {
            var url = 'gltf/DamagedHelmet/glTF/DamagedHelmet.gltf';
            return gltf.Ajax.getJSON(url, {}).then((json) => {
                const loader = new gltf.GLTFLoader('gltf/DamagedHelmet/glTF', json);
                return loader.load().then(gltfData => {
                    // console.log(gltfData);
                    const transformMat = mat4.identity([]);
                    mat4.rotate(transformMat,transformMat,90,[1,0,0]);
                    const modelMeshes = [];
                    const nodes = gltfData.scenes[0].nodes;
                    nodes.forEach((node, i) => {
                        if (!node.meshes && !node.children) {
                            return;
                        }
                        let meshes = null;
                        if (node.children) {
                            meshes = extractMesh(node.children);
                        } else if (node.meshes) {
                            meshes = node.meshes;
                        }
                        meshes.forEach(mesh => {
                            mesh.primitives.forEach(primitive => {
                                const modelGeometry = createGeometry(primitive);
                                //modelGeometry.generateBuffers(this.regl);//会抛elements must be array to build unique vertex.的异常，
                                const modelMesh = new reshader.Mesh(modelGeometry);
                                modelMeshes.push(modelMesh);
                                setPhongTexture(primitive.material, modelMesh);
                                modelMesh.setLocalTransform(transformMat);
                            });
                        });
                    });
                    const scene = new reshader.Scene(modelMeshes);
                    return scene;     
                });
            });
        }

        function createGeometry(primitive) {
            const attributes = {};
            for (const attr in primitive.attributes) {
                attributes[attr] =  primitive.attributes[attr].array;
            }
            const modelGeometry = new reshader.Geometry(
                attributes,
                primitive.indices,
                0,
                {
                    //绘制类型，例如 triangle strip, line等，根据gltf中primitive的mode来判断，默认是triangles
                    primitive : maptalks.Util.isNumber(primitive.mode) ? MODES[primitive.mode] : primitive.mode,
                    positionAttribute : 'POSITION',
                    normalAttribute : 'NORMAL',
                    
                }
            );
            return modelGeometry;
        }

        function getViewProjection(cameraPos) {
            const aspect = canvas.width / canvas.height;
            const projMatrix = mat4.perspective([], 60 * Math.PI / 180, aspect, cameraNearFar[0], cameraNearFar[1]);
            //const viewMatrix = mat4.lookAt([], cameraPos, [0, 0, 0], [0, 1, 0]);
            var xRotation = mat4.create();
            mat4.rotateY(xRotation, xRotation, roll);
            var yRotation = mat4.create();
            mat4.rotateX(yRotation, yRotation, pitch);
            var viewMatrix = mat4.create();
            mat4.multiply(viewMatrix, yRotation, xRotation);
            viewMatrix[14] = -translate;
            const projViewMatrix = mat4.multiply([], projMatrix, viewMatrix);
            return  { projViewMatrix, projMatrix, viewMatrix };
        }

        function clearFBO(){
            regl.clear({
                color: [1, 1, 1, 1],
                depth: 1,
                framebuffer : fbo_depth
            });
            regl.clear({
                color: [1, 1, 1, 1],
                depth: 1,
                framebuffer : fbo_a
            });
            regl.clear({
                color: [1, 1, 1, 1],
                depth: 1,
                framebuffer : fbo_b
            });
            regl.clear({
                color: [1, 1, 1, 1],
                depth: 1,
                framebuffer : fbo_c
            });
            regl.clear({
                color: [1, 1, 1, 1],
                depth: 1,
                framebuffer : fbo_d
            });
            regl.clear({
                color: [1, 1, 1, 1],
                depth: 1,
                framebuffer : fbo_e
            });
            regl.clear({
                color: [1, 1, 1, 1],
                depth: 1,
                framebuffer : fbo_f
            });
            regl.clear({
                color: [1, 1, 1, 1],
                depth: 1,
                framebuffer : fbo_g
            });
            regl.clear({
                color: [0, 0, 0, 1],
                depth: 1,
                framebuffer : fbo_edg
            });
        }

        //鼠标事件相关
        canvas.onmousedown = function(ev) { handleMouseDown(ev); };
        canvas.onmouseup = function(ev) { handleMouseUp(ev); };
        canvas.onmousemove = function(ev) { handleMouseMove(ev); };
        canvas.onwheel = function(ev) { handleWheel(ev); };

        function handleMouseDown(ev) {
            mouseDown = true;
            lastMouseX = ev.clientX;
            lastMouseY = ev.clientY;
        }

        function handleMouseUp(ev) {
            mouseDown = false;
        }

        function handleMouseMove(ev) {
            if (!mouseDown) {
                return;
            }
            var newX = ev.clientX;
            var newY = ev.clientY;

            var deltaX = newX - lastMouseX;
            roll += (deltaX / 100.0);

            var deltaY = newY - lastMouseY;
            pitch += (deltaY / 100.0);

            lastMouseX = newX;
            lastMouseY = newY;
            updateCamera();
        }
        function handleWheel(ev, redraw) {
            ev.preventDefault();
            if (ev.deltaY > 0) {
                translate *= wheelSpeed;
            }
            else {
                translate /= wheelSpeed;
            }
            updateCamera();
        }

        function updateCamera() {
            camPos = [-translate * Math.sin(roll) * Math.cos(-pitch),
            -translate * Math.sin(-pitch),
            translate * Math.cos(roll) * Math.cos(-pitch)];
        }
    </script>
  </body>
</html>
