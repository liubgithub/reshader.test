<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Red Cube</title>
<style type="text/css">
    html,
    body {
        margin: 0px;
        height: 100%;
        width: 100%
    }
</style>
<script type="text/javascript" src="./js/maptalks.js"></script>
<script src="js/maptalksgl-dev.js" type="text/javascript"></script>

<body>
    <canvas id="canvas" width = 1920 height = 900 class="container" style="border : 1px solid;position:absolute"></canvas>
    <canvas id="coastline" width = 1920 height = 900; style="background-color:black"></canvas>
    <select id="level"></select>
    <script type="module">
        import drawVert from './glsl/drawVert.js';
        import drawFrag from './glsl/drawFrag.js';
        import quadVert from './glsl/quadVert.js';
        import screenFrag from './glsl/screenFrag.js';
        import updateFrag from './glsl/updateFrag.js';
        import windVert from './glsl/windVert.js';
        import windFrag from './glsl/windFrag.js';
        let level = 0.0;
        const leftbuttom = [20, 30];
        const righttop = [120, 60];
        // const center = [120.0, 0.0];
        // const canvas.width = 900;
        const { createREGL, mat4, reshader } = maptalksgl;
        const defaultRampColors = {
            0.0: '#3288bd',
            0.1: '#66c2a5',
            0.2: '#abdda4',
            0.3: '#e6f598',
            0.4: '#fee08b',
            0.5: '#fdae61',
            0.6: '#f46d43',
            1.0: '#d53e4f'
        };
        const windData = {
            date: "2016-11-20T00:00Z",
            height: 180,
            url: './2016112000.png',
            source: "http://nomads.ncep.noaa.gov",
            uMax: 26.8,
            uMin: -21.32,
            vMax: 21.42,
            vMin: -21.57,
            width: 360
        }
        const fadeOpacity = 0.996; // how fast the particle trails fade on each frame
        const speedFactor = 0.25; // how fast the particles move
        const dropRate = 0.003; // how often the particles move to a random place
        const dropRateBump = 0.01; // drop rate increase relative to individual particle speed
        let colorRampTexture, backgroundTexture, screenTexture, particleStateTexture0, particleStateTexture1, windTexture;
        let particleStateResolution;
        let particleIndices;
        
        const regl = createREGL({
            canvas: canvas,
            extensions: [
                // 'ANGLE_instanced_arrays',
                // 'OES_texture_float',
                // 'OES_texture_float_linear',
                'OES_element_index_uint',
                'OES_standard_derivatives'
            ]
        });
        const fbo = regl.framebuffer({
            color: regl.texture({
                width: canvas.width,
                height: canvas.height
            }),
            depth: true
        })
        SetParticlesCount(256 * 256);
        canvas.onresize = resize;
        const viewport = {
            x: 0,
            y: 0,
            width: () => {
                return canvas.width;
            },
            height: () => {
                return canvas.height;
            }
        };

        const drawShader = new reshader.MeshShader({
            vert: drawVert,
            frag: drawFrag,
            uniforms: [
                'u_wind',
                'res',
                'level',
                'center',
                'u_particles',
                'u_color_ramp',
                'u_particles_res',
                'u_wind_min',
                'u_wind_max'
            ],
            extraCommandProps: { viewport,
                dither: true
            },
            defines: {}
        });

        const screenShader = new reshader.MeshShader({
            vert: quadVert,
            frag: screenFrag,
            uniforms: [
                'u_screen',
                'u_opacity'
            ],
            extraCommandProps: { viewport,
                dither: true
            },
            defines: {}
        });
        
        const windShader = new reshader.MeshShader({
            vert : windVert,
            frag : windFrag,
            uniforms : [
                'u_texture'
            ],
            extraCommandProps: { 
                viewport : {
                    x : 0,
                    y : 0,
                    width : canvas.width, 
                    height : canvas.height
                }
            },
            defines: {}
        });

        const updateSHader = new reshader.MeshShader({
            vert: quadVert,
            frag: updateFrag,
            uniforms: [
                'res',
                'center',
                'level',
                'u_wind',
                'u_particles',
                'u_rand_seed',
                'u_wind_res',
                'u_wind_min',
                'u_wind_max',
                'u_speed_factor',
                'u_drop_rate',
                'u_drop_rate_bump'
            ],
            extraCommandProps: { 
                viewport : {
                    x: 0,
                    y: 0,
                    width : () => {
                        return particleStateResolution;
                    },
                    height : () => {
                       return  particleStateResolution;
                    }
                },
                dither: true
             },
            defines: {}
        });

        const image = new Image();
        image.src = './2016112000.png';
        image.onload = () => {
            windData.image = image;
            windTexture = regl.texture({
                data: windData.image,
                mag: 'linear',
                min: 'linear'
            });
        }
        addSelect();
        setColorRamp(defaultRampColors);


        const renderer = new reshader.Renderer(regl);
        resize();
        const quadScene = getQuadScene();
        const framebuffer = regl.framebuffer({
            color: regl.texture({
                width : 1,
                height : 1
            }),
            depth: true
        });
        const raf = function () {
            if (windData.image) {
                render();
            }
            requestAnimationFrame(raf);
        }
        raf();
        //主绘制方法
        function render() {
            drawScreen();
            updateParticles();
        }
        
        function drawScreen() {
            framebuffer({
                color: screenTexture
            });
            drawParticles();
            renderer.render(screenShader, {
                u_screen: backgroundTexture,
                u_opacity: fadeOpacity
            }, quadScene, framebuffer);
            // renderer.render(screenShader, {
            //     u_screen: screenTexture,
            //     u_opacity: 1.0
            // }, quadScene);
            const windScene = getWindScene();
            renderer.render(windShader, {
                u_texture : screenTexture
            }, windScene);
            const temp = backgroundTexture;
            backgroundTexture = screenTexture;
            screenTexture = temp;
        }

        function drawParticles() {
            const particlesScene = getParticlesScene();
            renderer.render(drawShader,
                {
                    res : [canvas.width, canvas.height],
                    center : center,
                    level : level,
                    u_wind: windTexture,
                    u_particles: particleStateTexture0,
                    u_color_ramp: colorRampTexture,
                    u_particles_res: particleStateResolution,
                    u_wind_min: [windData.uMin, windData.vMin],
                    u_wind_max: [windData.uMax, windData.vMax]
                }, particlesScene, framebuffer);
        }

        function updateParticles() {
            framebuffer({
                color: particleStateTexture1
            });
            const quadScene = getQuadScene();
            renderer.render(updateSHader, {
                res : [canvas.width, canvas.height],
                center : center,
                level : level,
                u_wind: windTexture,
                u_particles: particleStateTexture0,
                u_rand_seed: Math.random(),
                u_wind_res: [windData.width, windData.height],
                u_wind_min: [windData.uMin, windData.vMin],
                u_wind_max: [windData.uMax, windData.vMax],
                u_speed_factor: speedFactor,
                u_drop_rate: dropRate,
                u_drop_rate_bump: dropRateBump,
            }, quadScene, framebuffer);

            const temp = particleStateTexture0;
            particleStateTexture0 = particleStateTexture1;
            particleStateTexture1 = temp;
        }

        function getQuadScene() {
            const plane = new reshader.Geometry({
                a_pos: [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1],
                uv : [0, 0, 
                1, 0, 
                0, 1, 
                0, 1, 
                1, 0, 
                1, 1]
            }, 6, 0, {
                    primitive: 'triangle',
                    positionAttribute: 'a_pos',
                    positionSize: 2
                });
            const planeMesh = new reshader.Mesh(plane);
            const scene = new reshader.Scene([planeMesh]);
            return scene;
        }

        function getWindScene() {
            const plane = new reshader.Geometry({
                a_pos: [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1],
                uv : [0, 0, 
                1, 0, 
                0, 1, 
                0, 1, 
                1, 0, 
                1, 1]
            }, 6, 0, {
                    primitive: 'triangle',
                    positionAttribute: 'a_pos',
                    positionSize: 2
                });
            const planeMesh = new reshader.Mesh(plane);
            const scene = new reshader.Scene([planeMesh]);
            return scene;
        }

        function getParticlesScene() {
            const particles = new reshader.Geometry({
                a_index: particleIndices,
            }, particleIndices.length, 0, {
                    primitive: 'point',
                    positionAttribute: 'a_index',
                    positionSize: 1
                });
            const particlesMesh = new reshader.Mesh(particles);
            const scene = new reshader.Scene([particlesMesh]);
            return scene;
        }

        function setColorRamp(colors) {
            // lookup texture for colorizing the particles according to their speed
            // this.colorRampTexture = util.createTexture(this.gl, this.gl.LINEAR, getColorRamp(colors), 16, 16);
            colorRampTexture = regl.texture({
                width: 16,
                height: 16,
                data: getColorRamp(colors),
                mag: 'linear',
                min: 'linear'
            });
        }

        function getColorRamp(colors) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = 256;
            canvas.height = 1;

            const gradient = ctx.createLinearGradient(0, 0, 256, 0);
            for (const stop in colors) {
                gradient.addColorStop(+stop, colors[stop]);
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 1);

            return new Uint8Array(ctx.getImageData(0, 0, 256, 1).data);
        }

        function SetParticlesCount(count) {
            // we create a square texture where each pixel will hold a particle position encoded as RGBA
            const particleRes = particleStateResolution = Math.ceil(Math.sqrt(count));
            const numParticles = particleRes * particleRes;

            const particleState = new Uint8Array(numParticles * 4);
            for (let i = 0; i < particleState.length; i++) {
                particleState[i] = Math.floor(Math.random() * 256); // randomize the initial particle positions
            }
            // textures to hold the particle state for the current and the next frame
            if (particleStateTexture0) {
                particleStateTexture0 = particleStateTexture0({
                    data: particleState,
                    width: particleRes,
                    height: particleRes
                });
            } else {
                particleStateTexture0 = regl.texture({
                    data: particleState,
                    width: particleRes,
                    height: particleRes
                });
            }
            
            if (particleStateTexture1) {
                particleStateTexture1 = particleStateTexture1({
                    data: particleState,
                    width: particleRes,
                    height: particleRes
                });
            } else {
                particleStateTexture1 = regl.texture({
                    data: particleState,
                    width: particleRes,
                    height: particleRes
                });
            }

            particleIndices = new Float32Array(numParticles);
            for (let i = 0; i < numParticles; i++) {
                particleIndices[i] = i;
            }
        }

        function _resize(e) {
            const width = canvas.width;
            const height = canvas.height;
            const emptyPixels = new Uint8Array(width * height * 4);
            // for (let i = 0; i < emptyPixels.length; i += 4) {
            //     emptyPixels[i] = 0;
            //     emptyPixels[i + 1] = 0;
            //     emptyPixels[i + 2] = 0;
            //     emptyPixels[i + 3] = 255;
            // }
            backgroundTexture = regl.texture({
                width,
                height,
                data: emptyPixels
            });
            screenTexture = regl.texture({
                width,
                height,
                data: emptyPixels
            });
        }

        function resize(e) {
            // const width = canvas.width;
            // const height = canvas.height;
            const emptyPixels = new Uint8Array(canvas.width * canvas.height * 4);
            backgroundTexture = regl.texture({
                width : canvas.width,
                height : canvas.height,
                data: emptyPixels
            });
            screenTexture = regl.texture({
                width : canvas.width,
                height : canvas.height,
                data: emptyPixels
            });
        }

        function addSelect() {
            const selelct = document.getElementById('level');
            for (let i = 0.0;i < 10.0; i = i + 1.0) {
                const option = document.createElement('option');
                option.innerText = i;
                selelct.appendChild(option);
            }
            selelct.onchange = function(e) {
                level = parseFloat(e.target.value);

                SetParticlesCount(256 * 256 / Math.pow(2, level));
            }
        }

        function wgs84ToMercator(xy) {
            // convert to angle
            let y = -180.0 * xy.y + 90.0;
            // use the formule to convert
            y = (180.0 - (180.0 / PI * Math.log(Math.tan(PI / 4.0 + y * PI / 360.0)))) / 360.0;
            // pass x through, as it doesn't change
            return { x : xy.x, y};
        }
    </script>
</body>

</html>